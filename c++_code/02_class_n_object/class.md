# C++结构体
C语言的结构体不允许有函数，定义结构体变量的方法是：
```c
struct 结构体名 结构体变量名;
```

在C++中，结构体的成员可以有函数，定义结构体变量可以用：
```c++
  结构体名 结构体变量名;
```
struct关键字可以不书写。


## C++ 类和对象
C++把结构体看成了类（class），类的成员可以是变量和函数，通过类定义出来的变量也有特定的称呼，叫做对象。

在C++中，用类定义一个类的变量叫做创建（或实例化）一个对象，成员变量称为类的属性（property），成员函数称为类的方法（method）。

类的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。

## 对象的指针
类是一种自定义的数据类型，对象是内存变量，有内存地址，当然也就有类的指针，就像结构体的指针一样。如下：
```c++
  CGirl queen;
  CGirl *pst=&queen;
```
通过类指针可以访问对象的成员，书写方法与结构体相同。
```c++
(*pointer).memberName
```
或者：
```c++
 pointer->memberName
```
上面的两种写法是等效的，我们通常采用后面的写法，这样更加直观。

## 对象的初始化和占用内存的大小
定义的变量使用前要初始化，C语言的基本数据类型可以直接赋值0，字符串和结构体用memset函数初始化，那么类的对象呢？对象不能用memset初始化，

对象可以用sizeof运算符获取占用内存的大小，但是，在实际开发中，程序员不太关心对象占用内存的大小。

## 类成员的访问权限
C++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符。所谓访问权限，就是类外面的代码访问该类中成员权限。

- 在类的内部，即类的成员函数中，无论成员被声明为 public、protected 还是 private，都是可以互相访问的，没有访问权限的限制。

- 在类的外部（定义类的代码之外），只能通过对象访问public的成员，不能访问 private、protected 属性的成员。

声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。如果既不写 private 也不写 public，就默认为 private。

在一个类体中，private 和 public 可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止

将成员变量全部设置为 public 省事，确实，这样做 99.9% 的情况下都不是一种错误，我也不认为这样做有什么不妥；但是，将成员变量设置为 private 是一种软件设计规范，尤其是在大中型项目中，还是请大家尽量遵守这一原则。

## 成员变量的命名
成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的参数名字区分开。

## 构造函数
在CFile类的声明中，有一些特殊的成员函数CFile()，它就是构造函数（constructor）。
```c++
  CFile();   // 类的构造函数
  CFile(bool bEnBuffer);   // 类的构造函数
```
构造函数具备以下特点：

1）构造函数必须是 public 属性。

2）构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。

3）构造函数可以有参数，允许重载。一个类可以有多个重载的构造函数，创建对象时根据传递的参数来判断调用哪一个构造函数。

4）构造函数在实际开发中会大量使用，它往往用来做一些初始化工作，对成员变量进行初始化等，注意，不能用memset对整个类进行初始化。

## 析构函数
在CFile类的声明中，还有一个特殊的成员函数~CFile()，它就是析构函数（destructor）。
```c++
~CFile();   // 类的析构函数
```
 析构函数的名字在类的名字前加~，没有返回值，但可以被显式的调用，在对象销毁时自动执行，用于进行清理工作，例如释放分配的内存、关闭打开的文件等，这个用途非常重要，可以防止程序员犯错。

析构函数具备以下特点：

1）析构函数必须是 public 属性的。

2）析构函数没有参数。

3）析构函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许。

4）析构函数不允许重载的。一个类只能有一个析构函数。
```c++
CFile::~CFile()   // 类的析构函数
{
  Close();  // 调用Close释放资源
}
```